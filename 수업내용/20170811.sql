--DAY 5 수업 내용

-- HAVING 절 :  GROUP BY 절 아래에 사용함
-- 반드시  GROUP BY 와 함께 사용하여야 함
-- 그룹 묶어서 계산한 그룹함수 결과값에 대한 조건처리임
-- SELECT 절에서는 HAVING 처리된 값만 조회됨.
--WHERE 절에서는 그룹함수 사용 불가 단일행함수만 사용가능
-- 부서별 급여 합계 중 9백만을 초과하는 부서와 급여합계 조회
SELECT DEPT_ID, SUM(SALARY)
FROM EMPLOYEE
GROUP BY DEPT_ID
HAVING SUM(SALARY) > 9000000;

--추가 함수

--분석 함수
--RANK() 함수 : 등수 또는 순위 처리하는 함수
--2가지 표현식이있다
--해당 값에 대한 순위를 알고자 할 때(전체 값에서 해당값의 순위를 알고자할때)
--RANK(순위를 알고자 하는 값) WITHIN GROUP (ORDER BY 컬럼명 정렬방식)
--급여 230만원이 전체급여중 몇 순위에 해당하는지 조회
SELECT RANK(2300000) WITHIN GROUP (ORDER BY SALARY DESC) AS 순위
FROM EMPLOYEE;

--전체 값의 순위를 매기고자 할 때
--RANK() OVER (ORDER BY 컬럼명 정렬방식)
SELECT EMP_NAME, SALARY, RANK() OVER (ORDER BY SALARY DESC) AS 순위
FROM EMPLOYEE;

--ROLLUP 함수 : GROUP BY 절에서만 사용함
--집계 결과값이 가장 아래쪽에 표시됨
SELECT DEPT_ID, SUM(SALARY)
FROM EMPLOYEE
WHERE DEPT_ID IS NOT NULL 
GROUP BY DEPT_ID;

SELECT DEPT_ID, SUM(SALARY)
FROM EMPLOYEE
WHERE DEPT_ID IS NOT NULL 
GROUP BY ROLLUP(DEPT_ID);

SELECT DEPT_ID, SUM(SALARY), MAX(SALARY), MIN(SALARY), AVG(SALARY)
FROM EMPLOYEE
WHERE DEPT_ID IS NOT NULL 
GROUP BY ROLLUP(DEPT_ID);


--CUBE 함수 : GROUP BY 절에서만 사용함
--총 집계 결과를 구함, 집계값이 위에 표시됨

SELECT DEPT_ID, SUM(SALARY), MAX(SALARY), MIN(SALARY), AVG(SALARY)
FROM EMPLOYEE
WHERE DEPT_ID IS NOT NULL 
GROUP BY CUBE(DEPT_ID);

SELECT DEPT_ID,MAX(SALARY), MIN(SALARY), AVG(SALARY)
FROM EMPLOYEE
WHERE DEPT_ID IS NOT NULL AND JOB_ID IS NOT NULL
GROUP BY ROLLUP(DEPT_ID,JOB_ID);

SELECT DEPT_ID,JOB_ID,MAX(SALARY), MIN(SALARY), AVG(SALARY)
FROM EMPLOYEE
WHERE DEPT_ID IS NOT NULL AND JOB_ID IS NOT NULL
GROUP BY ROLLUP(DEPT_ID,JOB_ID);
--GROUP BY ROLLUP(JOB_ID,DEPT_ID);

--GROUPING
--SELECT 절과 GROUP BY 절에서만 사용함
--컬럼 그룸 묶을 때 사용함
--그룹 묶어서 만든 집계값(1)인지 , 아닌지(0) 구분하는 용도로 사용함

--ROLLUP 과 CUBE 함수 사용시 이용하는 함수임

SELECT DEPT_ID, JOB_ID, SUM(SALARY), GROUPING(DEPT_ID) "부서별 그룹묶인 상태",GROUPING(JOB_ID) "직급별 묶인 상태"
FROM EMPLOYEE
WHERE DEPT_ID IS NOT NULL AND JOB_ID IS NOT NULL
GROUP BY ROLLUP(DEPT_ID,JOB_ID);

SELECT DEPT_ID, JOB_ID, SUM(SALARY), GROUPING(DEPT_ID) "부서별 그룹묶인 상태",GROUPING(JOB_ID) "직급별 묶인 상태"
FROM EMPLOYEE
WHERE DEPT_ID IS NOT NULL AND JOB_ID IS NOT NULL
GROUP BY CUBE(DEPT_ID,JOB_ID);

--GROUPING SETS
--그룹별로 묶어서 계산한 여러 개의 SELECT 문들을 하나로 합친 결과를 원할때 사용함
--집합연산자 (SET OPERATOR) 중에서 UNION ALL 사용과 결과가 동일함

SELECT DEPT_ID, JOB_ID, MGR_ID, AVG(SALARY)
FROM EMPLOYEE
GROUP BY DEPT_ID, JOB_ID, MGR_ID
UNION ALL
SELECT DEPT_ID , NULL, MGR_ID, AVG(SALARY)
FROM EMPLOYEE
GROUP BY DEPT_ID, MGR_ID
UNION ALL
SELECT NULL, JOB_ID, MGR_ID, AVG (SALARY)
FROM EMPLOYEE
GROUP BY MGR_ID, JOB_ID;

SELECT DEPT_ID, JOB_ID, MGR_ID, AVG(SALARY)
FROM EMPLOYEE
GROUP BY GROUPING SETS((DEPT_ID, JOB_ID, MGR_ID),
                                      (DEPT_ID, MGR_ID),
                                      (MGR_ID, JOB_ID));
                                      
--ROWID
--ROWNUM

--*************************************************************************
--조인 (JOIN)
--여러 개의 테이블을 하나의 큰 테이블로 합친 결과를 원할 때 사용함
--조인 구문은 오라클에서만 사용하는 오라클 전용 구문화
--모든 DBMS가 공통으로 사용하는 표준구문인 ASCI 표준구문 두 가지를 사용할 수 있음

--오라클 전용 구문
-- 합칠 테이블명들을 위한 컬럼명과 조건식을 WHERE 절에 명시함
SELECT *
FROM EMPLOYEE, DEPARTMENT
WHERE EMPLOYEE.DEPT_ID = DEPARTMENT.DEPT_ID;

SELECT *
FROM EMPLOYEE E, DEPARTMENT D
WHERE E.DEPT_ID = D.DEPT_ID;

SELECT E.EMP_NAME, D.DEPT_NAME
FROM EMPLOYEE E, DEPARTMENT D
WHERE E.DEPT_ID = D.DEPT_ID;

--ANSI 표준구문과 오라클 전용구문 차이 공부!
--USING
SELECT *
FROM EMPLOYEE
JOIN DEPARTMENT USING (DEPT_ID);

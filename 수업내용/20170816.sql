--DAY6 수업내용

--JOIN
--두테이블에 중복되는 칼럼이 존재한다면 조인가능?!
--테이블 별칭 가능

SELECT *
FROM EMPLOYEE E, DEPARTMENT D
WHERE E.DEPT_ID = D.DEPT_ID; 
--이상 (INNER) JOIN 
--일반적인 JOIN은 INNER 조인을 말한다.
/*
ANSI 표준 구문
[LEFT/RIGHT/FULL] (OUTER) JOIN   ( )생략가능
[USING/ON] 
OUTER JOIN은 두테이블의 합집합과 비슷한 개념
LEFT는 두 테이블 중 처음 선언한 테이블에 기초를 두고 두 번째 선언한 테이블을 조인한다.
RIGHT는 두 테이블 중 처음 선언한 테이블에 기초를 두는 것이아닌 두 번째 선언한 테이블에 기초를 두고 첫 번째 선언한 테이블을 조인한다.
USING은 두칼럼명이 같을때
ON은 두컬럼명이 다를 때

NATURAL JOIN -- 두 테이블을 기본 키로 조인
CROSS JOIN -- 각 테이블의 행 X 행 만큼의 레코드가 생기는 조인
*/

--INNER JOIN ORACLE 전용 구문
SELECT *
FROM EMPLOYEE E, JOB J
WHERE E.JOB_ID = J.JOB_ID;

--INNER JOIN ANSI 표준 구문
SELECT *
FROM EMPLOYEE
INNER JOIN JOB USING (JOB_ID);

--OUTER JOIN ORACLE 전용 구문
SELECT *
FROM EMPLOYEE E, JOB J
WHERE E.JOB_ID = J.JOB_ID(+);

--LEFT (OUTER) JOIN ANSI 표준 구문
SELECT *
FROM EMPLOYEE
LEFT JOIN JOB USING (JOB_ID);

--INNER JOIN 과 OUTER JOIN 은 EQUAL JOIN 이다.
--두 테이블의 조인조건 컬럼이 서로 일치하는 값일 때

--오른쪽 테이블을 기준으로 
SELECT EMP_NAME, E.DEPT_ID, D.DEPT_ID, DEPT_NAME
FROM EMPLOYEE E, DEPARTMENT D
WHERE E.DEPT_ID = D.DEPT_ID(+);

SELECT EMP_NAME, DEPT_ID, DEPT_NAME
FROM DEPARTMENT
RIGHT OUTER JOIN EMPLOYEE USING (DEPT_ID);

SELECT EMP_NAME, E.DEPT_ID, D.DEPT_ID, DEPT_NAME
FROM EMPLOYEE E, DEPARTMENT D
WHERE E.DEPT_ID(+) = D.DEPT_ID;

SELECT EMP_NAME, DEPT_ID, DEPT_NAME
FROM EMPLOYEE
RIGHT OUTER JOIN DEPARTMENT USING (DEPT_ID);

SELECT EMP_NAME, E.DEPT_ID, D.DEPT_ID, DEPT_NAME
FROM EMPLOYEE E, DEPARTMENT D
WHERE E.DEPT_ID(+) = D.DEPT_ID(+); 
--오류 오라클전용 구문으로 FULL OUTER JOIN 불가능

SELECT EMP_NAME, DEPT_ID, DEPT_NAME
FROM EMPLOYEE
FULL OUTER JOIN DEPARTMENT USING (DEPT_ID);

SELECT EMP_NAME, JOB_TITLE,LOC_DESCRIBE, COUNTRY_NAME 
FROM EMPLOYEE E, JOB J, DEPARTMENT D,LOCATION L, COUNTRY C
WHERE E.JOB_ID = J.JOB_ID AND 
          E.DEPT_ID = D.DEPT_ID AND
          D.LOC_ID = L.LOCATION_ID AND
          L.COUNTRY_ID = C.COUNTRY_ID;
          
--  ORACLE
SELECT EMP_ID, EMP_NAME, JOB_TITLE, DEPT_NAME, LOC_DESCRIBE, SALARY
FROM EMPLOYEE E, JOB J, DEPARTMENT D, LOCATION L
WHERE E.JOB_ID = J.JOB_ID
AND E.DEPT_ID = D.DEPT_ID
AND D.LOC_ID = L.LOCATION_ID
AND JOB_TITLE LIKE '대리'
AND LOC_DESCRIBE LIKE '아시아%';
--  ANSI
SELECT EMP_ID, EMP_NAME, JOB_TITLE, DEPT_NAME, LOC_DESCRIBE, SALARY
FROM EMPLOYEE
INNER JOIN JOB USING (JOB_ID)
INNER JOIN DEPARTMENT USING(DEPT_ID)
INNER JOIN LOCATION ON(DEPARTMENT.LOC_ID = LOCATION.LOCATION_ID)
WHERE JOB_TITLE LIKE '대리'
AND LOC_DESCRIBE LIKE '아시아%';

--  ORACLE
SELECT EMP_NAME, DEPT_NAME, LOC_DESCRIBE, COUNTRY_NAME
FROM EMPLOYEE E, DEPARTMENT D, LOCATION L, COUNTRY C
WHERE E.DEPT_ID = D.DEPT_ID
AND D.LOC_ID = L.LOCATION_ID
AND L.COUNTRY_ID = C.COUNTRY_ID
AND COUNTRY_NAME IN ('한국','일본');

--  ANSI
SELECT EMP_NAME, DEPT_NAME, LOC_DESCRIBE, COUNTRY_NAME
FROM EMPLOYEE
INNER JOIN DEPARTMENT USING(DEPT_ID)
INNER JOIN LOCATION ON(DEPARTMENT.LOC_ID = LOCATION.LOCATION_ID)
INNER JOIN COUNTRY ON(LOCATION.COUNTRY_ID=COUNTRY.COUNTRY_ID)
WHERE COUNTRY_NAME IN('한국','일본');

--ORACLE
SELECT EMP_NAME 사원명, JOB_TITLE 직급명, SALARY 급여, ((SALARY+(SALARY*NVL(BONUS_PCT,0)))*12) 연봉
FROM EMPLOYEE E, JOB J
WHERE E.JOB_ID = J.JOB_ID
AND ((SALARY+(SALARY*NVL(BONUS_PCT,0)))*12)>MIN_SAL;
--ANSI
SELECT EMP_NAME 사원명, JOB_TITLE 직급명, SALARY 급여, ((SALARY+(SALARY*NVL(BONUS_PCT,0)))*12) 연봉
FROM EMPLOYEE
INNER JOIN JOB USING(JOB_ID)
WHERE ((SALARY+(SALARY*NVL(BONUS_PCT,0)))*12)>MIN_SAL;

SELECT EMP_NAME, JOB_TITLE, SALARY
FROM EMPLOYEE
INNER JOIN JOB USING(JOB_ID)
WHERE BONUS_PCT IS NULL 
AND JOB_ID IN('J4','J7');

SELECT EMP_NAME, J.JOB_TITLE, SALARY
FROM EMPLOYEE E, JOB J
WHERE E.JOB_ID = J.JOB_ID
AND BONUS_PCT IS NULL
AND E.JOB_ID IN('J4','J7');

--ANSI
SELECT A.EMP_NAME 사원명, A.DEPT_ID 부서코드, B.EMP_NAME 동료이름
FROM EMPLOYEE A
JOIN EMPLOYEE B
ON A.EMP_NAME <> B.EMP_NAME 
AND A.DEPT_ID = B.DEPT_ID
ORDER BY A.EMP_NAME;

--ORACLE
SELECT A.EMP_NAME 사원명, A.DEPT_ID 부서코드, B.EMP_NAME 동료이름
FROM EMPLOYEE A, EMPLOYEE B
WHERE A.DEPT_ID = B.DEPT_ID
AND A.EMP_NAME NOT LIKE B.EMP_NAME
ORDER BY A.EMP_NAME;

SELECT COUNT(DECODE(MARRIAGE,'Y','1',''))AS 기혼, COUNT(DECODE(MARRIAGE,'N','1',''))AS 미혼
FROM EMPLOYEE
WHERE DEPT_ID IN('50','90');

SELECT DECODE(MARRIAGE,'Y','기혼','N','미혼')AS 결혼유무, COUNT(*) 직원수
FROM EMPLOYEE
WHERE DEPT_ID IN('50','90')
GROUP BY DECODE(MARRIAGE,'Y','기혼','N','미혼')
ORDER BY 1;

SELECT EMP_NAME,
LOC_DESCRIBE,
DEPT_NAME
FROM EMPLOYEE
CROSS JOIN LOCATION
JOIN DEPARTMENT USING (DEPT_ID)
WHERE LOCATION_ID = LOC_ID;


SELECT EMP_ID,
EMP_NAME,
'관리자' AS 구분
FROM EMPLOYEE
WHERE EMP_ID = '141'
AND DEPT_ID = '50'
UNION
SELECT EMP_ID,
EMP_NAME,
'직원' AS 구분
FROM EMPLOYEE
WHERE DEPT_ID = '50'
AND EMP_ID != '141'
ORDER BY 3, 1;


--시험문제 출제 가능성!
SELECT EMP_ID,
ROLE_NAME
FROM EMPLOYEE_ROLE
JOIN ROLE_HISTORY USING (EMP_ID, ROLE_NAME);

SELECT E.EMP_ID, R.ROLE_NAME
FROM EMPLOYEE_ROLE E, ROLE_HISTORY R
WHERE E.EMP_ID = R.EMP_ID
AND E.ROLE_NAME = R.ROLE_NAME;

SELECT EMP_ID,
ROLE_NAME
FROM EMPLOYEE_ROLE
INTERSECT
SELECT EMP_ID,
ROLE_NAME
FROM ROLE_HISTORY;

SELECT EMP_NAME,
JOB_ID,
SALARY
FROM EMPLOYEE
WHERE JOB_ID = (SELECT JOB_ID
FROM EMPLOYEE
WHERE EMP_NAME = '나승원')
AND SALARY > (SELECT SALARY
FROM EMPLOYEE
WHERE EMP_NAME = '나승원') ;

